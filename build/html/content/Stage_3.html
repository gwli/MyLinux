<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>专题篇 &mdash; My Linux 0.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="My Linux 0.3 documentation" href="../index.html" />
    <link rel="prev" title="内核篇" href="Stage_2.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Stage_2.html" title="内核篇"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">My Linux 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>专题篇<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linux-bootup">
<h2>linux bootup<a class="headerlink" href="#linux-bootup" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linux">
<h3>linux 的生与死<a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h3>
<p>先由BIOS上电之后，由BIOS决定你从哪一个分区起，然后BIOS把对应分区的上bootloader 加载。然后bootloader把kernel的代码，以及所需要东东，都加载到内存里放一个地方。然后再kernel开始初始内存，建立内存表，以及中断表等等之后，然后才是种driver的加载。然后各个东东才开始各自的执行。builtin与module进去，采用都是相同的结构。module的内存结构。
内存结构可以用http://code.metager.de/source/xref/linux/utils/kmod/libkmod/libkmod-module.c#63 这里看到，采用的struct然后里边就是指针了。形成一个列表。insmod,rmmod插入，列表，查询列表的过程。</p>
<p>linux 启动模式是由 <a class="reference external" href="http://linux.ccidnet.com/art/9513/20070428/1072625&amp;#95;1.html">linux的运行模式：Runlevel详细解析</a>  决定的，它是由 <a class="reference external" href="http://book.51cto.com/art/200906/127324.htm">/etc/inittab</a>  来控制的，telinit 是用来发送信号进行init. shutdown reboot都是跟 runlevel相关，默认的level,都在rc.XX.d下软链接，并且也是00-99的数字，并且SK表示特殊的意义来开始。原来的GTL的方式是在学习RC 机制。</p>
<p>对于系统的控制，很大部分那就是各种service的起动的控制，系统基本起来了，就是各种服务进程，这个主要就在init.d这个阶段进行，如何开机自己等都是在此做的，同时自己需要一些定制的也主要集中此的。</p>
<p>对于ubuntu简单直接，/ect/rc.local就可以了。并且可以查看rc.d 这个目录下东东。 这个每个系统也是不一样的。同时有些系统已经支持并行启动了，例如SUSE中已经支持了。具休可查看/ect/rc.d/README,并且在/etc/rc.d/boot中控制。 一旦并行就会有步同步依赖的问题，也这也是各种before,after 机制的原因，这些就是用来控制顺序的吧。</p>
<p>实践上 init 现在已经支持并行了，并且之间也是有依赖关系与event的话，起动依赖配置放在 /etc/init/XX.conf中, 所以当然也可以对此的应用如此的定制。</p>
<p>gentoo用OPENRC来实现一套并行机制，</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c1"># show dependency</span>
rc-udpate show
<span class="c1"># add</span>
rc-update add root boot
<span class="c1"># get all service list</span>
rc-service -l
</pre></div>
</div>
<div class="section" id="id2">
<h4>如何把添加卡到默认启动<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre><span class="nb">cd</span> /etc/init.d/
cp net.eth0  net.&lt;newid&gt;
rc-update delete net.eth0 default
rc-update add  net.&lt;newid&gt; default
</pre></div>
</div>
<p>gentoo os 有时候发现开机启动后根目录是只读，可能的原因就是 <code class="file docutils literal"><span class="pre">/etc/init.d/root</span></code> 没有加到启动项中。
<a class="reference external" href="https://wiki.gentoo.org/wiki/OpenRC">https://wiki.gentoo.org/wiki/OpenRC</a></p>
<p>centos则采用的队列来实现机制。<a class="reference external" href="http://man7.org/linux/man-pages/man7/dracut.modules.7.html">http://man7.org/linux/man-pages/man7/dracut.modules.7.html</a>
主要的功能那就是rc本身也支持语法输法，这样就可以很方便的进行定制。
init 是一个event-based daemon,1号进程. 给出更宽泛的地义，那是context, exec 等等。 只管输入输出，与环境变量。
<a class="reference external" href="http://linuxmafia.com/faq/Admin/init.html">http://linuxmafia.com/faq/Admin/init.html</a>， <em>sbin/init</em>  是第一进程。 rc-.&gt;(run control).
<a class="reference external" href="http://leaf.sourceforge.net/doc/bootproc.html,linuxrc-">http://leaf.sourceforge.net/doc/bootproc.html,linuxrc-</a>&gt;init-&gt;RC.</p>
<p>各家系统的对比。
<a class="reference external" href="https://wiki.gentoo.org/wiki/Comparison_of_init_systems">https://wiki.gentoo.org/wiki/Comparison_of_init_systems</a></p>
<p>以及现在XIP, execute in place技术，直接起动，而不需要加载,例如使用ROM等等。这样可以大大加快启动的速度。这种一般是直接从 flash来读kernel，主要是一些嵌入式的设备。 直接启动。而不需要向PC这样的复杂。而这一块做的最好当属于现在的手机系统。
<a class="reference external" href="http://www.denx.de/wiki/bin/view/DULG/ConfigureLinuxForXIP">How to config XIP</a></p>
<p>对于SUSE 是有一些麻烦，要用到http://unix.stackexchange.com/questions/43230/how-to-run-my-script-after-suse-finished-booting-up， 写标准init 脚本并注册了。当然也简单的做法例如直接/etc/rc.d/after.local 等来进行hook, <a class="reference external" href="http://www.linuxidc.com/Linux/2012-09/71020.htm">http://www.linuxidc.com/Linux/2012-09/71020.htm</a>.
对于windows 来说，也就是注册表了开机启动了。
不同的系统对于这部分都有不同的优化。</p>
<p>ubuntu 中bootup <a class="reference external" href="https://help.ubuntu.com/community/UbuntuBootupHowto">https://help.ubuntu.com/community/UbuntuBootupHowto</a>, 并且这里有一个service 的模板可以用。</p>
</div>
</div>
<div class="section" id="id3">
<h3>内核的启动与一般函数调用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>是一样的，或者一个复杂的命令行而己，就像gcc一样，哪些自身的参数，哪些是传给你init,哪些是传给module中。
都可以在这里查到的。
<a class="reference external" href="http://man7.org/linux/man-pages/man7/bootparam.7.html">http://man7.org/linux/man-pages/man7/bootparam.7.html</a>
<a class="reference external" href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt">https://www.kernel.org/doc/Documentation/kernel-parameters.txt</a></p>
<p>启动三步grub</p>
<div class="highlight-bash"><div class="highlight"><pre>grub&gt; <span class="nb">set</span> <span class="nv">root</span><span class="o">=(</span>hd0,1<span class="o">)</span>
grub&gt; linux /boot/vmlinuz-4.4.xxx-generic xxxxoptions
grub&gt; initrd /boot/initrd.img-xxxxx-generic
grub&gt; boot
</pre></div>
</div>
<p>例如要不要使用 initrd,可以直接使用 noinitrd,就可以了。具体其他的起动参数都是可以从上面的文档中查到。如果使用initrd,内核启动就会为两个阶段
#. 内核启动前， grub会把initrd 先加载到内存中
#. 内核启动后，先利用 initird中一些文件，来完成加载驱动模块，
#. 执行 /sbin/init</p>
<p>为什么会用initrd,因为所有的驱动加载内核是不现实的，内核中只包含基本驱动，initrd则根据硬件来定制。
另外利用USB启动时，使用initrd文件是可以加速的。 具体原因见 https//www.ibm.com/developerworks/cn/linux/l-k26initrd/</p>
<p>对于启动的时候，initramfs 都是initrd的压缩版，只是把当前文件系统的一些东东直接cpio,gzip打包成.img而己。并且也都有现成工具可以来做。
<a class="reference external" href="http://www.stlinux.com/howto/initramfs">http://www.stlinux.com/howto/initramfs</a>
<a class="reference external" href="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/index.html">http://www.ibm.com/developerworks/cn/linux/l-k26initrd/index.html</a>
<a class="reference external" href="https://wiki.ubuntu.com/Initramfs">https://wiki.ubuntu.com/Initramfs</a>
<a class="reference external" href="http://lugatgt.org/content/booting.inittools/downloads/presentation.pdf">http://lugatgt.org/content/booting.inittools/downloads/presentation.pdf</a></p>
<div class="section" id="initrd">
<h4>解压 initrd<a class="headerlink" href="#initrd" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre>cp  /boot/initrd.img-<span class="sb">`</span>uname-r<span class="sb">`</span> .
file XXX.img
mv  XXX.gz
gunzip XXXX.gz
file XXXX
cpio -idmv &lt; XXXX
</pre></div>
</div>
<p>对于initramfs 的制作，每一个平台都有专门的工具来做。 例如， redhat 有 <a class="reference external" href="http://people.redhat.com/harald/dracut.html">dracut</a>
什么需要呢，例如些module没有编译在内核里，但是启动又需要的。这些就需要的。这样可以启动内核做的很少，然后灵活的定制。 这里就有一个问题，操作系统是什么加载driver的。
并且由bootloader 利用 initrd 建立一个  / root system. 并在这里起动 kernel.
<a class="reference external" href="http://www.mjmwired.net/kernel/Documentation/initrd.txt">http://www.mjmwired.net/kernel/Documentation/initrd.txt</a>
read the init code of linux kernel. to understand the shell and interpreter programming.
<a class="reference external" href="http://bbs.chinaunix.net/thread-3685404-1-1.html">Linux系统下init进程的前世今生</a>   <a class="reference external" href="http://lxr.linux.no/linux-old+v0.11/init/main.c#L168">init/main.c sourcecode</a></p>
<p>当你更改了系统的启动配置，就需要更新一个initramfs,这样才能保证起动不不加载。经常遇到现象，那就 /etc/modprubes.d/nvidia-installer-disable-nouveau.conf中 blacklist nouevu 但是起动时还是加载了。</p>
<p>一个终极办法，那直接发在 <code class="file docutils literal"><span class="pre">/lib/modules/xxxxkernel_version/kernel/drivers/gpu/drm/nouveau/nouveau.ko</span></code> 的改名。
然后 <strong class="command">update-inittramfs -u</strong> 更新一下。 而 <code class="file docutils literal"><span class="pre">/etc/initramfs-tools</span></code> 是其配置文件。</p>
<p><a class="reference external" href="http://wenku.baidu.com/view/f439355777232f60ddcca152.html">Linux系统启动过程分析详解</a>
module 加载在 /etc/init.d/kmod 里实现的加载哪一个driver,并且加载的顺序。而这些应该在init之前。</p>
<p><a class="reference external" href="http://leaf.sourceforge.net/doc/bootproc.html">http://leaf.sourceforge.net/doc/bootproc.html</a> 这里说细的linux启动流程。</p>
<p>并且启动过程是可以打断的加入参数 break=init就可以了，或者在起动的时候按快捷键，例如按 <code class="kbd docutils literal"><span class="pre">I</span></code> for gentoo os. <a href="#id5"><span class="problematic" id="id6">`</span></a><a class="reference external" href="https://wiki.debian.org/BootProcess">https://wiki.debian.org/BootProcess</a></p>
<p>init 开始并行化，event_base化。
<a class="reference external" href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a>，有各种各样的 init.</p>
<p>mdev是用来创建 /dev的目录， 使用方法
<a class="reference external" href="https://git.busybox.net/busybox/tree/docs/mdev.txt?h=1_18_stable">https://git.busybox.net/busybox/tree/docs/mdev.txt?h=1_18_stable</a></p>
<p>所以当你发现硬件没有发现的时候，直接使用 <strong class="command">mdev -s</strong>, 就可以了。</p>
<p>或者</p>
<div class="highlight-bash"><div class="highlight"><pre>mount -t sysfs sysfs /sys
sysctl -w kernel.hotplug<span class="o">=</span>/sbin/mdev
mdev -s
</pre></div>
</div>
<p>在GUI login运行的用startup Applications Preferences.
用命令行， gnome-session-properties来管理，同时也可以~/.config/autostart下面能看到。
<a class="reference external" href="http://askubuntu.com/questions/303694/where-is-startup-applications-user-config-file-for-disabled-and-enabled-applic">http://askubuntu.com/questions/303694/where-is-startup-applications-user-config-file-for-disabled-and-enabled-applic</a></p>
<p>并且启动的log都放在dmesg中，如果log不全，可以把dmesg改大。 dmesg是内核缓冲区的内容，printk就是打印到这里。
所以遇到起动问题，直接看/var/log/dmesg 中。直接通用搜索关键字来得到。
内存的log的级别是可调，哪些级别打印console上也都是受此控制的。在起动的时候，</p>
<p>所谓的sesssion 也就是context另一个叫法，同时session &lt;==&gt;context&lt;==&gt;environment. 三种基本上是等价的一个概念只在不同level上。
另一个编程语言的也有类似的概念。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1">#do something</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>无盘启动<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>到现在为止，我们已经用过U盘启动，光盘启动,到现在的无盘启动。</p>
<ol class="arabic simple">
<li>U盘启动我们用的是syslinux实现的</li>
<li>光盘启动，我们的是isolinux来实现的</li>
<li>无盘启动，我们需要PXElinux来做了。</li>
</ol>
<p>实现步骤</p>
<ol class="arabic simple">
<li>设置网卡支持网盘启动</li>
<li>DHCP server上指定 tftp server 的地址，以及需要开机启动文件与配置</li>
<li>然后PXE client 下载并执行</li>
</ol>
<p>启动的核心，从哪里下载启动镜象，并且启动。并且在一个现有的网络中，DHCP server是由IP控制的，并不能随意的改变，一个更加灵活的方案，那就是替换网卡的PXE固件，然后可以任意指定地址来进行
现在网卡中默认的都是 <a class="reference external" href="http://ipxe.org/">http://ipxe.org/</a> 客户端</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c1">#Press Ctrl-B at this point, and you should reach the iPXE command line:</span>
iPXE&gt;
<span class="c1">#You can list the network devices that iPXE has detected using the ifstat command:</span>
iPXE&gt; ifstat
  net0: 52:54:00:12:34:56 using rtl8139 on PCI00:03.0 <span class="o">(</span>closed<span class="o">)</span>
    <span class="o">[</span>Link:up, TX:0 TXE:0 RX:0 RXE:0<span class="o">]</span>
<span class="c1">#and acquire an IP address using the dhcp command:</span>
  iPXE&gt; dhcp
  DHCP <span class="o">(</span>net0 52:54:00:12:34:56<span class="o">)</span>.... ok
<span class="c1">#You can examine the IP configuration and other DHCP options:</span>

  iPXE&gt; route
  net0: 10.0.0.155/255.255.255.0 gw 10.0.0.1
  iPXE&gt; show dns
  net0.dhcp/dns:ipv4 <span class="o">=</span> 10.0.0.6
<span class="c1">#You can boot something over the network. Unlike a traditional PXE ROM, iPXE is able to boot over a wide area network such as the Internet. If the machine you are testing is connected to the Internet, you can boot the iPXE demonstration script:</span>

  iPXE&gt; chain http://boot.ipxe.org/demo/boot.php
</pre></div>
</div>
<p>boot.php 的内容</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="ch">#!ipxe</span>

kernel vmlinuz-3.16.0-rc4 <span class="nv">bootfile</span><span class="o">=</span>http://boot.ipxe.org/demo/boot.php fastboot <span class="nv">initrd</span><span class="o">=</span>initrd.img
initrd initrd.img
</pre></div>
</div>
<p>boot</p>
</div>
<div class="section" id="how-to-config-pxe-server">
<h3>how to config PXE server<a class="headerlink" href="#how-to-config-pxe-server" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://blog.csdn.net/robertkun/article/details/16851109">http://blog.csdn.net/robertkun/article/details/16851109</a></p>
<ol class="arabic">
<li><p class="first">copy the form ISO cd</p>
<div class="highlight-bash"><div class="highlight"><pre>cp /mnt/iso/isolinux/isolinux.cfg      /tftpboot/pxelinux.cfg/default
cp /mnt/iso/images/pxeboot/initrd.img  /tftpboot/
cp /mnt/iso/images/pxeboot/vmlinuz     /tftpboot/
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="boot-from-nfs">
<h3>boot from nfs<a class="headerlink" href="#boot-from-nfs" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://ipxe.org/appnote/ubuntu_live">http://ipxe.org/appnote/ubuntu_live</a></p>
</div>
<div class="section" id="boot-from-http">
<h3>boot from http<a class="headerlink" href="#boot-from-http" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://ipxe.org/appnote/xenserver">http://ipxe.org/appnote/xenserver</a>
可以参考这个试一试</p>
</div>
<div class="section" id="id8">
<h3>动态的启动脚本<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>这样还可以从自动的生成配置文件</p>
<div class="highlight-bash"><div class="highlight"><pre>http://192.168.0.1/boot.php?mac<span class="o">=</span><span class="si">${</span><span class="nv">net0</span><span class="p">/mac</span><span class="si">}</span><span class="p">&amp;</span><span class="nv">asset</span><span class="o">=</span><span class="si">${</span><span class="nv">asset</span><span class="p">:</span><span class="nv">uristring</span><span class="si">}</span>
</pre></div>
</div>
</div>
<div class="section" id="booting-from-pxe-of-realtek-of-agent">
<h3>Booting from PXE of Realtek of agent<a class="headerlink" href="#booting-from-pxe-of-realtek-of-agent" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://www.ipcop.org/1.4.0/en/install/html/installing-from-pxe-boot.html">http://www.ipcop.org/1.4.0/en/install/html/installing-from-pxe-boot.html</a></p>
</div>
<div class="section" id="id9">
<h3>无盘启动方案<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">安装网卡，并注册网卡信息</p>
</li>
<li><dl class="first docutils">
<dt>自举安装safeos</dt>
<dd><ol class="first last arabic simple">
<li>检查自己是否需要安装safeos</li>
<li>自safeos中添加自己demo 在GTL service之前，然后自动提交service中。</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>safeos 启动之后</dt>
<dd><ol class="first last arabic simple">
<li>是否刷机</li>
<li>reserve 机器</li>
<li>刷机</li>
<li>unreserve 机器</li>
<li>自动更新 E:windows OS自动配置</li>
<li>自动设置 Stage to 1</li>
</ol>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="tty-console">
<h3>tty console<a class="headerlink" href="#tty-console" title="Permalink to this headline">¶</a></h3>
<p>现在终于明白了tty的设计原理了。简单的理解，就是一个socket通信。并且把两端通用化。例如一些编辑的功能，例如具备一些editor的初步功能。
一个最简单功能，那就是直接for循环，就可以搞定。拿浏览器来做对比，就会一目了然，那就是终端也需要一定的rendering功能。 而这些不是应用程序本身需要
考虑的功能。</p>
<p>未来的terminal 趋向于全终端editor+ browser + session management 的功能。例如QTconsole能够支持图表与公式的功能。</p>
<p>例如tmux 来实现多session的管理。以及asciinema 的录制。
以及各个session之间的共享，其实就是socket的组播功能。</p>
<p>pts的原理，<a class="reference external" href="http://www.baike.com/ipadwiki/PTS">http://www.baike.com/ipadwiki/PTS</a></p>
<p>ssh,telnet这些与在本地的xterm都同相同地方，那就是其输入输出连接一个终端。并且都是双工通信或者三工通信，in,out,error.  而对于终端来说，那就是一个master,slave,一个读一个写。要正好与进程之间反过来才行。 而这些都是要终端打交道。</p>
<p>/dev/console 总是指向系统的TTY，它决定了系统的信息往哪里输出，/dev/tty0总是指向当前的tty, tty[1-x] 则是独立逻辑tty设备。</p>
</div>
<div class="section" id="terminal">
<h3>terminal 中显示符号<a class="headerlink" href="#terminal" title="Permalink to this headline">¶</a></h3>
<p>这个关键是编码与字体的支持，只要有两者的支持就能显示，例如 <a class="reference external" href="https://unix.stackexchange.com/questions/96591/is-it-possible-to-show-mathematical-symbols-in-the-terminal">在terminal中显示数学符号</a></p>
</div>
<div class="section" id="shell">
<h3>远程网络shell之间<a class="headerlink" href="#shell" title="Permalink to this headline">¶</a></h3>
<p>ssh 的过程。
远程网络终端和本机shell之间建立了一条双向通道&#8211;“远程网络终端-(套接字)&#8211;本机协议处理进程&#8211;主终端&#8211;从终端&#8211;shell”</p>
</div>
<div class="section" id="serial-io">
<h3>serial IO 的原理<a class="headerlink" href="#serial-io" title="Permalink to this headline">¶</a></h3>
<p>CPU -&gt; driver -&gt;bus -&gt;I/O pin
<a class="reference external" href="http://www.tldp.org/HOWTO/Serial-HOWTO-4.html">http://www.tldp.org/HOWTO/Serial-HOWTO-4.html</a></p>
</div>
<div class="section" id="io">
<h3>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h3>
<p>对于linux 中每一个程序都会有三个默认的IO，0 标准输入，1标准输出，2标准error输。 其实它们于正常的文件打开是一样的。 只是他们打开的是设备文件，而这个是filesystem
已经帮我们进行屏蔽了。 并且里程的继承关系，默认情况下，每起一个进程都会默认继承复进程的东东。所以你看到大部分程序输入与输出都在同一个地方，键盘与屏幕。</p>
<p>而真实的过程就是可以是任意的文件。你可以起动一个进程的时候就指定 0，1，2的变化。
用代码控制就是dup2 直接 link 一个系统里打开的文件，包括其读写的位置。相当于共享一个文件。 (而不是真实的复制，只是复制的两者就没有关系了，这个从man dup2 的说明就可以看，这就是文件系统的一个link ). 所以两个指针写，一个读。 并且把这个文件属于写不完就行， 只是需要建立一个buffer,然后在此基础上实现一个循环队列就搞定了，头尾两个指针，用于读，一个用写就行了。</p>
<p>文件同时会读写两个指针，但是为了避免冲突，程序使用一个文件不会同时即读又写的。</p>
<p>Pipefs文件系统不需要太大，只是需要循环的链表，并且基于字节的两个指针而己。这个是个文件不是独占，共享指针。</p>
<p>从文件中读取的方式，可以按行读，也可以按字切读，当然也可以是扫描式的读，那就是scanf. 以前读这种读法，不理解，现在终于理解了。</p>
<p>所以我们读写对应是一个FD,把可以这个FD任意的变换，现在对于M4 的对于输出那么灵活重定向明白了其实现原理。</p>
<p><a class="reference external" href="http://blog.csdn.net/dog250/article/details/7484102">http://blog.csdn.net/dog250/article/details/7484102</a>
<a class="reference external" href="http://www.cnblogs.com/weidagang2046/p/io-redirection.html">http://www.cnblogs.com/weidagang2046/p/io-redirection.html</a>
<a class="reference external" href="http://bbs.chinaunix.net/thread-2079678-1-1.html">http://bbs.chinaunix.net/thread-2079678-1-1.html</a></p>
<p><a class="reference external" href="http://my.oschina.net/u/158589/blog/69047">http://my.oschina.net/u/158589/blog/69047</a>  这一篇讲的就不太对了</p>
<p>对于IO的读写，是各个系统很重要的一部分。
也就是 read,write后面的原理。是如何内存读写过来的。
select,poll都是能够针对FD是事件进行检测。
linux 把IO都当做一个文件，所有与相关的事件是不是都应该用可以select,poll来读写呢。
硬件的变化，可以硬件的线路反馈给CPU，然后CPU现在都已经可以达700-1000个引角。能实现
的功能大大复杂了。
<a class="reference external" href="http://www.cnblogs.com/xkfz007/archive/2012/10/08/2715163.html">http://www.cnblogs.com/xkfz007/archive/2012/10/08/2715163.html</a></p>
<p>像文件读写也是一样的，需要一定的结构，把各个引脚的状态放在内存里。那些管脚有一半为供电的。</p>
<p>exec 用法，也就加载segment,以及data段的过程，并且几种不同接口都是针对具体的细节的应用。例如要不要不环境变量等等。</p>
<p>例如现在想看到一个进程的输出怎么办法，可直接可用 tail -f /proc/fd/1。 或者debugger attach上去就可查看输出了。或者直接用ptrace来修改其输出。
<strong class="command">strace -ewrite -p $pid</strong></p>
<p>使用linux watch 命令。</p>
<p>或者像https://etbe.coker.com.au/2008/02/27/redirecting-output-from-a-running-process/这样 用gdb来实现</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gdb</span> <span class="o">-</span><span class="n">p</span> <span class="n">pid</span> <span class="n">execfile</span>
<span class="n">p</span> <span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">p</span> <span class="n">creat</span><span class="p">(</span><span class="s">&quot;/tmp/newlog&quot;</span><span class="p">,</span><span class="mo">0600</span><span class="p">)</span> <span class="n">or</span> <span class="n">dup2</span>
<span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">pid</span><span class="o">/</span><span class="n">fd</span>
<span class="n">ls</span>
</pre></div>
</div>
<p>同样如何连接http://unix.stackexchange.com/questions/31824/how-to-attach-terminal-to-detached-process</p>
<div class="highlight-cpp"><div class="highlight"><pre>mkifo /tmp/fifo
gdb -p PID
p close(0)
p open(&#39;tmp/fifo&#39;,0600)
echo balahs&gt;fifo
</pre></div>
</div>
<p>当然也会些相关的小工具http://pasky.or.cz//dev/retty/, <a class="reference external" href="http://pasky.or.cz//dev/retty/,http://pasky.or.cz//dev/retty/">http://pasky.or.cz//dev/retty/,http://pasky.or.cz//dev/retty/</a></p>
</div>
</div>
<div class="section" id="usboverip">
<h2>USBOverIP<a class="headerlink" href="#usboverip" title="Permalink to this headline">¶</a></h2>
<p>现在这个是linux已经支持的protocal, USBoverIP.
你可以 apt-install usbip
但是在 14.04是 linux-tools-genric-lts&#8211;utopic.</p>
<p>命令行工具在 <code class="file docutils literal"><span class="pre">/usr/lib/linux-lts-uptoic-tools-xxx.xx/</span></code></p>
<div class="section" id="id11">
<h3>基本流程<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">server</p>
<div class="highlight-bash"><div class="highlight"><pre>./usbipd -D

<span class="c1">#check what device on local</span>
./usbip list -l

<span class="c1"># bind the device to the server</span>
./usbip <span class="nb">bind</span> -b 3-3
<span class="c1">#or</span>
./usbip <span class="nb">bind</span> -b 3-3:1.0
</pre></div>
</div>
</li>
<li><p class="first">client</p>
<div class="highlight-bash"><div class="highlight"><pre>./usbip list -r &lt;remotehostip&gt;
./usbip attach
</pre></div>
</div>
</li>
</ol>
<p>但在ubuntu14.04 跑不起来。</p>
<div class="highlight-bash"><div class="highlight"><pre>../usbipd -D -d
libuspip: error:  udev_device_get_sysattr_value failed
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/torvalds/linux/tree/master/tools/usb/usbip">https://github.com/torvalds/linux/tree/master/tools/usb/usbip</a>
<a class="reference external" href="https://github.com/solarkennedy/wiki.xkyle.com/wiki/USB-over-IP-On-Ubuntu">https://github.com/solarkennedy/wiki.xkyle.com/wiki/USB-over-IP-On-Ubuntu</a>
<a class="reference external" href="https://github.com/forensix/libusbip">https://github.com/forensix/libusbip</a></p>
</div>
</div>
<div class="section" id="id12">
<h2>linux bootup<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>linux 的生与死<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>先由BIOS上电之后，由BIOS决定你从哪一个分区起，然后BIOS把对应分区的上bootloader 加载。然后bootloader把kernel的代码，以及所需要东东，都加载到内存里放一个地方。然后再kernel开始初始内存，建立内存表，以及中断表等等之后，然后才是种driver的加载。然后各个东东才开始各自的执行。builtin与module进去，采用都是相同的结构。module的内存结构。
内存结构可以用http://code.metager.de/source/xref/linux/utils/kmod/libkmod/libkmod-module.c#63 这里看到，采用的struct然后里边就是指针了。形成一个列表。insmod,rmmod插入，列表，查询列表的过程。</p>
<p>linux 启动模式是由 <a class="reference external" href="http://linux.ccidnet.com/art/9513/20070428/1072625&amp;#95;1.html">linux的运行模式：Runlevel详细解析</a>  决定的，它是由 <a class="reference external" href="http://book.51cto.com/art/200906/127324.htm">/etc/inittab</a>  来控制的，telinit 是用来发送信号进行init. shutdown reboot都是跟 runlevel相关，默认的level,都在rc.XX.d下软链接，并且也是00-99的数字，并且SK表示特殊的意义来开始。原来的GTL的方式是在学习RC 机制。</p>
<p>对于系统的控制，很大部分那就是各种service的起动的控制，系统基本起来了，就是各种服务进程，这个主要就在init.d这个阶段进行，如何开机自己等都是在此做的，同时自己需要一些定制的也主要集中此的。</p>
<p>对于ubuntu简单直接，/ect/rc.local就可以了。并且可以查看rc.d 这个目录下东东。 这个每个系统也是不一样的。同时有些系统已经支持并行启动了，例如SUSE中已经支持了。具休可查看/ect/rc.d/README,并且在/etc/rc.d/boot中控制。 一旦并行就会有步同步依赖的问题，也这也是各种before,after 机制的原因，这些就是用来控制顺序的吧。</p>
<p>实践上 init 现在已经支持并行了，并且之间也是有依赖关系与event的话，起动依赖配置放在 /etc/init/XX.conf中, 所以当然也可以对此的应用如此的定制。</p>
<p>gentoo用OPENRC来实现一套并行机制，</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c1"># show dependency</span>
rc-udpate show
<span class="c1"># add</span>
rc-update add root boot
<span class="c1"># get all service list</span>
rc-service -l
</pre></div>
</div>
<div class="section" id="id16">
<h4>如何把添加卡到默认启动<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre><span class="nb">cd</span> /etc/init.d/
cp net.eth0  net.&lt;newid&gt;
rc-update delete net.eth0 default
rc-update add  net.&lt;newid&gt; default
</pre></div>
</div>
<p>gentoo os 有时候发现开机启动后根目录是只读，可能的原因就是 <code class="file docutils literal"><span class="pre">/etc/init.d/root</span></code> 没有加到启动项中。
<a class="reference external" href="https://wiki.gentoo.org/wiki/OpenRC">https://wiki.gentoo.org/wiki/OpenRC</a></p>
<p>centos则采用的队列来实现机制。<a class="reference external" href="http://man7.org/linux/man-pages/man7/dracut.modules.7.html">http://man7.org/linux/man-pages/man7/dracut.modules.7.html</a>
主要的功能那就是rc本身也支持语法输法，这样就可以很方便的进行定制。
init 是一个event-based daemon,1号进程. 给出更宽泛的地义，那是context, exec 等等。 只管输入输出，与环境变量。
<a class="reference external" href="http://linuxmafia.com/faq/Admin/init.html">http://linuxmafia.com/faq/Admin/init.html</a>， <em>sbin/init</em>  是第一进程。 rc-.&gt;(run control).
<a class="reference external" href="http://leaf.sourceforge.net/doc/bootproc.html,linuxrc-">http://leaf.sourceforge.net/doc/bootproc.html,linuxrc-</a>&gt;init-&gt;RC.</p>
<p>各家系统的对比。
<a class="reference external" href="https://wiki.gentoo.org/wiki/Comparison_of_init_systems">https://wiki.gentoo.org/wiki/Comparison_of_init_systems</a></p>
<p>以及现在XIP, execute in place技术，直接起动，而不需要加载,例如使用ROM等等。这样可以大大加快启动的速度。这种一般是直接从 flash来读kernel，主要是一些嵌入式的设备。 直接启动。而不需要向PC这样的复杂。而这一块做的最好当属于现在的手机系统。
<a class="reference external" href="http://www.denx.de/wiki/bin/view/DULG/ConfigureLinuxForXIP">How to config XIP</a></p>
<p>对于SUSE 是有一些麻烦，要用到http://unix.stackexchange.com/questions/43230/how-to-run-my-script-after-suse-finished-booting-up， 写标准init 脚本并注册了。当然也简单的做法例如直接/etc/rc.d/after.local 等来进行hook, <a class="reference external" href="http://www.linuxidc.com/Linux/2012-09/71020.htm">http://www.linuxidc.com/Linux/2012-09/71020.htm</a>.
对于windows 来说，也就是注册表了开机启动了。
不同的系统对于这部分都有不同的优化。</p>
<p>ubuntu 中bootup <a class="reference external" href="https://help.ubuntu.com/community/UbuntuBootupHowto">https://help.ubuntu.com/community/UbuntuBootupHowto</a>, 并且这里有一个service 的模板可以用。</p>
</div>
</div>
<div class="section" id="id18">
<h3>内核的启动与一般函数调用<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>是一样的，或者一个复杂的命令行而己，就像gcc一样，哪些自身的参数，哪些是传给你init,哪些是传给module中。
都可以在这里查到的。
<a class="reference external" href="http://man7.org/linux/man-pages/man7/bootparam.7.html">http://man7.org/linux/man-pages/man7/bootparam.7.html</a>
<a class="reference external" href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt">https://www.kernel.org/doc/Documentation/kernel-parameters.txt</a></p>
<p>启动三步grub</p>
<div class="highlight-bash"><div class="highlight"><pre>grub&gt; <span class="nb">set</span> <span class="nv">root</span><span class="o">=(</span>hd0,1<span class="o">)</span>
grub&gt; linux /boot/vmlinuz-4.4.xxx-generic xxxxoptions
grub&gt; initrd /boot/initrd.img-xxxxx-generic
grub&gt; boot
</pre></div>
</div>
<p>例如要不要使用 initrd,可以直接使用 noinitrd,就可以了。具体其他的起动参数都是可以从上面的文档中查到。如果使用initrd,内核启动就会为两个阶段
#. 内核启动前， grub会把initrd 先加载到内存中
#. 内核启动后，先利用 initird中一些文件，来完成加载驱动模块，
#. 执行 /sbin/init</p>
<p>为什么会用initrd,因为所有的驱动加载内核是不现实的，内核中只包含基本驱动，initrd则根据硬件来定制。
另外利用USB启动时，使用initrd文件是可以加速的。 具体原因见 https//www.ibm.com/developerworks/cn/linux/l-k26initrd/</p>
<p>对于启动的时候，initramfs 都是initrd的压缩版，只是把当前文件系统的一些东东直接cpio,gzip打包成.img而己。并且也都有现成工具可以来做。
<a class="reference external" href="http://www.stlinux.com/howto/initramfs">http://www.stlinux.com/howto/initramfs</a>
<a class="reference external" href="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/index.html">http://www.ibm.com/developerworks/cn/linux/l-k26initrd/index.html</a>
<a class="reference external" href="https://wiki.ubuntu.com/Initramfs">https://wiki.ubuntu.com/Initramfs</a>
<a class="reference external" href="http://lugatgt.org/content/booting.inittools/downloads/presentation.pdf">http://lugatgt.org/content/booting.inittools/downloads/presentation.pdf</a></p>
<div class="section" id="id19">
<h4>解压 initrd<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre>cp  /boot/initrd.img-<span class="sb">`</span>uname-r<span class="sb">`</span> .
file XXX.img
mv  XXX.gz
gunzip XXXX.gz
file XXXX
cpio -idmv &lt; XXXX
</pre></div>
</div>
<p>对于initramfs 的制作，每一个平台都有专门的工具来做。 例如， redhat 有 <a class="reference external" href="http://people.redhat.com/harald/dracut.html">dracut</a>
什么需要呢，例如些module没有编译在内核里，但是启动又需要的。这些就需要的。这样可以启动内核做的很少，然后灵活的定制。 这里就有一个问题，操作系统是什么加载driver的。
并且由bootloader 利用 initrd 建立一个  / root system. 并在这里起动 kernel.
<a class="reference external" href="http://www.mjmwired.net/kernel/Documentation/initrd.txt">http://www.mjmwired.net/kernel/Documentation/initrd.txt</a>
read the init code of linux kernel. to understand the shell and interpreter programming.
<a class="reference external" href="http://bbs.chinaunix.net/thread-3685404-1-1.html">Linux系统下init进程的前世今生</a>   <a class="reference external" href="http://lxr.linux.no/linux-old+v0.11/init/main.c#L168">init/main.c sourcecode</a></p>
<p>当你更改了系统的启动配置，就需要更新一个initramfs,这样才能保证起动不不加载。经常遇到现象，那就 /etc/modprubes.d/nvidia-installer-disable-nouveau.conf中 blacklist nouevu 但是起动时还是加载了。</p>
<p>一个终极办法，那直接发在 <code class="file docutils literal"><span class="pre">/lib/modules/xxxxkernel_version/kernel/drivers/gpu/drm/nouveau/nouveau.ko</span></code> 的改名。
然后 <strong class="command">update-inittramfs -u</strong> 更新一下。 而 <code class="file docutils literal"><span class="pre">/etc/initramfs-tools</span></code> 是其配置文件。</p>
<p><a class="reference external" href="http://wenku.baidu.com/view/f439355777232f60ddcca152.html">Linux系统启动过程分析详解</a>
module 加载在 /etc/init.d/kmod 里实现的加载哪一个driver,并且加载的顺序。而这些应该在init之前。</p>
<p><a class="reference external" href="http://leaf.sourceforge.net/doc/bootproc.html">http://leaf.sourceforge.net/doc/bootproc.html</a> 这里说细的linux启动流程。</p>
<p>并且启动过程是可以打断的加入参数 break=init就可以了，或者在起动的时候按快捷键，例如按 <code class="kbd docutils literal"><span class="pre">I</span></code> for gentoo os. <a href="#id24"><span class="problematic" id="id25">`</span></a><a class="reference external" href="https://wiki.debian.org/BootProcess">https://wiki.debian.org/BootProcess</a></p>
<p>init 开始并行化，event_base化。
<a class="reference external" href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a>，有各种各样的 init.</p>
<p>mdev是用来创建 /dev的目录， 使用方法
<a class="reference external" href="https://git.busybox.net/busybox/tree/docs/mdev.txt?h=1_18_stable">https://git.busybox.net/busybox/tree/docs/mdev.txt?h=1_18_stable</a></p>
<p>所以当你发现硬件没有发现的时候，直接使用 <strong class="command">mdev -s</strong>, 就可以了。</p>
<p>或者</p>
<div class="highlight-bash"><div class="highlight"><pre>mount -t sysfs sysfs /sys
sysctl -w kernel.hotplug<span class="o">=</span>/sbin/mdev
mdev -s
</pre></div>
</div>
<p>在GUI login运行的用startup Applications Preferences.
用命令行， gnome-session-properties来管理，同时也可以~/.config/autostart下面能看到。
<a class="reference external" href="http://askubuntu.com/questions/303694/where-is-startup-applications-user-config-file-for-disabled-and-enabled-applic">http://askubuntu.com/questions/303694/where-is-startup-applications-user-config-file-for-disabled-and-enabled-applic</a></p>
<p>并且启动的log都放在dmesg中，如果log不全，可以把dmesg改大。 dmesg是内核缓冲区的内容，printk就是打印到这里。
所以遇到起动问题，直接看/var/log/dmesg 中。直接通用搜索关键字来得到。
内存的log的级别是可调，哪些级别打印console上也都是受此控制的。在起动的时候，</p>
<p>所谓的sesssion 也就是context另一个叫法，同时session &lt;==&gt;context&lt;==&gt;environment. 三种基本上是等价的一个概念只在不同level上。
另一个编程语言的也有类似的概念。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1">#do something</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h3>无盘启动<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>到现在为止，我们已经用过U盘启动，光盘启动,到现在的无盘启动。</p>
<ol class="arabic simple">
<li>U盘启动我们用的是syslinux实现的</li>
<li>光盘启动，我们的是isolinux来实现的</li>
<li>无盘启动，我们需要PXElinux来做了。</li>
</ol>
<p>实现步骤</p>
<ol class="arabic simple">
<li>设置网卡支持网盘启动</li>
<li>DHCP server上指定 tftp server 的地址，以及需要开机启动文件与配置</li>
<li>然后PXE client 下载并执行</li>
</ol>
<p>启动的核心，从哪里下载启动镜象，并且启动。并且在一个现有的网络中，DHCP server是由IP控制的，并不能随意的改变，一个更加灵活的方案，那就是替换网卡的PXE固件，然后可以任意指定地址来进行
现在网卡中默认的都是 <a class="reference external" href="http://ipxe.org/">http://ipxe.org/</a> 客户端</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c1">#Press Ctrl-B at this point, and you should reach the iPXE command line:</span>
iPXE&gt;
<span class="c1">#You can list the network devices that iPXE has detected using the ifstat command:</span>
iPXE&gt; ifstat
  net0: 52:54:00:12:34:56 using rtl8139 on PCI00:03.0 <span class="o">(</span>closed<span class="o">)</span>
    <span class="o">[</span>Link:up, TX:0 TXE:0 RX:0 RXE:0<span class="o">]</span>
<span class="c1">#and acquire an IP address using the dhcp command:</span>
  iPXE&gt; dhcp
  DHCP <span class="o">(</span>net0 52:54:00:12:34:56<span class="o">)</span>.... ok
<span class="c1">#You can examine the IP configuration and other DHCP options:</span>

  iPXE&gt; route
  net0: 10.0.0.155/255.255.255.0 gw 10.0.0.1
  iPXE&gt; show dns
  net0.dhcp/dns:ipv4 <span class="o">=</span> 10.0.0.6
<span class="c1">#You can boot something over the network. Unlike a traditional PXE ROM, iPXE is able to boot over a wide area network such as the Internet. If the machine you are testing is connected to the Internet, you can boot the iPXE demonstration script:</span>

  iPXE&gt; chain http://boot.ipxe.org/demo/boot.php
</pre></div>
</div>
<p>boot.php 的内容</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="ch">#!ipxe</span>

kernel vmlinuz-3.16.0-rc4 <span class="nv">bootfile</span><span class="o">=</span>http://boot.ipxe.org/demo/boot.php fastboot <span class="nv">initrd</span><span class="o">=</span>initrd.img
initrd initrd.img
</pre></div>
</div>
<p>boot</p>
</div>
<div class="section" id="id27">
<h3>how to config PXE server<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://blog.csdn.net/robertkun/article/details/16851109">http://blog.csdn.net/robertkun/article/details/16851109</a></p>
<ol class="arabic">
<li><p class="first">copy the form ISO cd</p>
<div class="highlight-bash"><div class="highlight"><pre>cp /mnt/iso/isolinux/isolinux.cfg      /tftpboot/pxelinux.cfg/default
cp /mnt/iso/images/pxeboot/initrd.img  /tftpboot/
cp /mnt/iso/images/pxeboot/vmlinuz     /tftpboot/
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="id28">
<h3>boot from nfs<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://ipxe.org/appnote/ubuntu_live">http://ipxe.org/appnote/ubuntu_live</a></p>
</div>
<div class="section" id="id29">
<h3>boot from http<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://ipxe.org/appnote/xenserver">http://ipxe.org/appnote/xenserver</a>
可以参考这个试一试</p>
</div>
<div class="section" id="id30">
<h3>动态的启动脚本<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>这样还可以从自动的生成配置文件</p>
<div class="highlight-bash"><div class="highlight"><pre>http://192.168.0.1/boot.php?mac<span class="o">=</span><span class="si">${</span><span class="nv">net0</span><span class="p">/mac</span><span class="si">}</span><span class="p">&amp;</span><span class="nv">asset</span><span class="o">=</span><span class="si">${</span><span class="nv">asset</span><span class="p">:</span><span class="nv">uristring</span><span class="si">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h3>Booting from PXE of Realtek of agent<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://www.ipcop.org/1.4.0/en/install/html/installing-from-pxe-boot.html">http://www.ipcop.org/1.4.0/en/install/html/installing-from-pxe-boot.html</a></p>
</div>
<div class="section" id="id32">
<h3>无盘启动方案<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">安装网卡，并注册网卡信息</p>
</li>
<li><dl class="first docutils">
<dt>自举安装safeos</dt>
<dd><ol class="first last arabic simple">
<li>检查自己是否需要安装safeos</li>
<li>自safeos中添加自己demo 在GTL service之前，然后自动提交service中。</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>safeos 启动之后</dt>
<dd><ol class="first last arabic simple">
<li>是否刷机</li>
<li>reserve 机器</li>
<li>刷机</li>
<li>unreserve 机器</li>
<li>自动更新 E:windows OS自动配置</li>
<li>自动设置 Stage to 1</li>
</ol>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="input">
<h3>Input设备<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h3>
<p>核心问题，如何实现硬件输入与逻辑对象之间的映射。</p>
<img alt="http://www.emyard.com/wp-content/uploads/2018/05/clip_image002.jpg" src="http://www.emyard.com/wp-content/uploads/2018/05/clip_image002.jpg" />
<img alt="http://www.emyard.com/wp-content/uploads/2018/05/clip_image003.jpg" src="http://www.emyard.com/wp-content/uploads/2018/05/clip_image003.jpg" />
<p>Document/input/input-programming.txt
键盘模式：
键盘模式有4种， 在Linux 下可以用vc_kbd_mode（老版本中是kbd_mode）参数来设置和显示模式：
1） Scancode mode （raw ）raw模式：将键盘端口上读出的扫描码放入缓冲区
2） Keycode mode (mediumraw) mediumraw模式：将扫描码过滤为键盘码放入缓冲区
3） ASCII mode (XLATE ) XLATE模式：识别各种键盘码的组合，转换为TTY终端代码放入缓冲区
4） UTF-8 MODE (UNICODE) Unicode 模式：UNICODE模式基本上与XLATE相同，只不过可以通过数字小键盘间接输入UNICODE代码。
&nbsp;&nbsp; 在keyboard.c中，不涉及底层操作，也不涉及到任何体系结构，他主要负责：键盘初始化、键盘tasklet的挂入、按键盘后的处理、keymap的装入、scancode的转化、与TTY设备的通信</p>
<ol class="arabic">
<li><p class="first">信号流程</p>
<ul class="simple">
<li>硬件中断-&gt; input subsystem-&gt;</li>
</ul>
</li>
<li><p class="first">udev的关系</p>
<ul class="simple">
<li>/lib/udev/hwdb.d/60-keyboard.hwdb,键盘的mapping也都在这个文件里。</li>
</ul>
</li>
<li><p class="first">linux 各个位置文件的位置</p>
</li>
<li><p class="first">触摸屏的检测， 可以driver检测然后上报 input-subsystem. 只是前端不同。对于后端可以保持不变。
* 触摸屏的虚拟键，只要driver能识别上报就行。</p>
</li>
<li><p class="first">如何troubleshoot
* evtest  :* apt install evtest*
* xev</p>
<div class="highlight-bash"><div class="highlight"><pre>udevadm hwdb --update
udevadm trigger /dev/input/eventXX
</pre></div>
</div>
</li>
</ol>
<p>从这个 <a href="#id109"><span class="problematic" id="id110">`https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1597415`_</span></a> 分析开始。</p>
<p>硬件与driver 的关联是在</p>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/proc/bus/input/devices 这里对应的， handlers + devices.
* In /lib/udev/hwdb.d/60-keyboard.hwdb</p>
<p>最终真实硬件，都会变成文件对象，其实大部分的硬件都是基于寄存器的，无非提供了硬件复用机制，就像CPU一样，同样的道理适用于其他硬件，首先每一个硬件抽象化，然后映射到真实硬件的部分。而每一个抽象硬件，都有其独立寄存器，就像所谓的context,正所谓的open,close其实本质就是实现一个小的context,并且实现环境切换以得到复用，这也是 with context manager的实现的原理。</p>
<p><a class="reference external" href="http://baike.baidu.com/link?url=xSR7hRAezhCFEgGa2o1n8ncvsY1LgnI1Qx6xahZpBQjuJ9pLzyIPJK1bakVVQqvKL5k1x-zdbDX-E2tk8ZM3Aa">ioctl</a> 大部分硬件都是基于寄存器，而一段时间内得到具体控制可以用ioctl来对I/O 通道进行管理。</p>
<p>对于xterm 更是如此，同一套硬件，还要多欠mapping,输入的多次，输出的多次。</p>
<p>所谓的无非就是查看共同一块数据而己，同时具有读写功能。本质那就是对同一个文件进行同时打开两次，并且都具有读写功能。这个也就是os.openpty,的功能，先得到pty,然后再打开一次，相当于一个主，一个slave.
可以用 os.open打开同一个文件即可。并且不用缓冲区即可。</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="http://wenku.baidu.com/view/a6c4b6bfc77da26925c5b001.html">linux input子系统详截</a></li>
<li><a class="reference external" href="http://www.linuxidc.com/Linux/2011-06/37906.htm">Android 【真机】与【模拟器】触摸屏事件的模拟差异分析</a></li>
<li><a class="reference external" href="http://bbs.chinaunix.net/thread-2080479-1-1.html">区分/dev/tty、/dev/console、/dev/pts、/dev/ttyn</a></li>
</ul>
</div>
<div class="section" id="thinking">
<h4>thinking<a class="headerlink" href="#thinking" title="Permalink to this headline">¶</a></h4>
<p><em>sendEvent</em>
linux内核是支持事件，与输入设备的操作，你可以加入伪信号来实现，例如发送一个事件，就像windows下面的那sendMessage一样。直接像设备发送十六进制数据来模拟各种操作。就相当于直接写寄存器了。</p>
<p>&#8211; Main.GangweiLi - 27 Oct 2012</p>
<p><em>/dev/full /dev/zero   /dev/null  /dev/random</em>
/dev 下面有各种各样的特殊设备，例如些都可以模枋一些低层需求。</p>
<p>&#8211; Main.GangweiLi - 03 Apr 2013</p>
<p><em>wall</em> sends a message to everybody logged in with their mesg permission.</p>
<p>linux实现了对物理设备与逻辑设备的映射关系。当然了映射关系，再加上context机制的分时，就可以分时复用了。同时我们还可以做一些伪设备来发送数据。来达到虚拟化的效果，并且这个mapping规范化就是虚拟机了。
原来进程模型，stdin指就是键盘，而stdout就是文本显示器。同时出错也是显示器。
进程再输入与输出以出错信息。在linux都是以文件方式来进行。</p>
<p>最原来的字符终端设备已经没有了，所以理解起来比较困难。本身就是一个显示与输出，有类似于键盘+屏幕一样的。 但是伪终端，从设备这一端与进程相联系的，而主役备是由窗口管理系统控制，与真正的终端的mapping是内核与窗口管理系统控制。 就是缓冲区，采用类似于进程一样的结构，来达到复用的效果。</p>
<p>linux 分三大块，CPU,内存，I/O. 最复杂的也就是IO设备，也就需要各种各样的驱动了。
对于终端的各种key的翻译可以用 stty 来进行设备，例如backspace是删除等等都保存在termio中。</p>
<p>pty 是采用的动态分配的机制，每一次需要的时候去 打开 ptmx 会自动得到主设备，然后去打开一个从设备，然后主从之间就可以通信了。就像pipe 是一样的。</p>
</div>
<div class="section" id="id35">
<h4>操作模型<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>open /dev/ptmx 得到 master fd_master</li>
<li>grantpt(fd_master)</li>
<li>unlockpt(fdm)</li>
<li>slavename = ptsname(fd_master)</li>
<li>fd_slave=open(slavename)</li>
</ol>
<p><a class="reference external" href="http://wenku.baidu.com/view/53d0daf8aef8941ea76e05d2.html">http://wenku.baidu.com/view/53d0daf8aef8941ea76e05d2.html</a></p>
<p>其实也简单，只要共享同一个文件就行了，并且实时更新，相当于共享了session. 也就是我们要共享shession. 例如ssh 共享session. 在python 中有直接pty模块，也可以spawn pty.</p>
<p>X.Org X Server 1.6.5
Release Date: 2009-10-11
X Protocol Version 11, Revision 0
Build Operating System: openSUSE SUSE LINUX
Current Operating System: Linux DEVTOOLS-QA70 2.6.32.12-0.7-default #1 SMP 2010-05-20 11:14:20 +0200 x86_64
Build Date: 09 May 2010  12:50:35PM</p>
<blockquote>
<div>Before reporting problems, check <a class="reference external" href="http://wiki.x.org">http://wiki.x.org</a>
to make sure that you have the latest version.</div></blockquote>
<dl class="docutils">
<dt>Markers: (&#8211;) probed, (**) from config file, (==) default setting,</dt>
<dd>(++) from command line, (!!) notice, (II) informational,
(WW) warning, (EE) error, (NI) not implemented, (??) unknown.</dd>
</dl>
<p>(==) Log file: &#8220;/var/log/Xorg.0.log&#8221;, Time: Wed Feb  4 06:42:13 2015
(==) Using config file: &#8220;/etc/X11/xorg.conf&#8221;
(==) ServerLayout &#8220;Layout[all]&#8221;
(**) <a href="#id36"><span class="problematic" id="id37">|</span></a>&#8211;&gt;Screen &#8220;Screen[0]&#8221; (0)
(**) |   <a href="#id38"><span class="problematic" id="id39">|</span></a>&#8211;&gt;Monitor &#8220;Monitor[0]&#8221;
(**) |   <a href="#id40"><span class="problematic" id="id41">|</span></a>&#8211;&gt;Device &#8220;Device[0]&#8221;
(**) <a href="#id42"><span class="problematic" id="id43">|</span></a>&#8211;&gt;Input Device &#8220;Keyboard[0]&#8221;
(**) <a href="#id44"><span class="problematic" id="id45">|</span></a>&#8211;&gt;Input Device &#8220;Mouse[1]&#8221;
(**) Option &#8220;ZapWarning&#8221; &#8220;on&#8221;
(**) Option &#8220;AllowMouseOpenFail&#8221; &#8220;on&#8221;
(**) Option &#8220;Xinerama&#8221; &#8220;off&#8221;
(==) Not automatically adding devices
(==) Automatically enabling devices
(WW) The directory &#8220;/usr/share/fonts/local&#8221; does not exist.</p>
<blockquote>
<div>Entry deleted from font path.</div></blockquote>
<dl class="docutils">
<dt>(WW) The directory &#8220;/usr/share/fonts/PEX&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/latin2/misc&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/latin2/75dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/latin2/100dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/latin2/Type1&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/latin7/75dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/baekmuk&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/japanese&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/kwintv&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/uni&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/CID&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/ucs/misc&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/ucs/75dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/ucs/100dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/hellas/misc&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/hellas/75dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/hellas/100dpi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/hellas/Type1&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/misc/sgi&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/xtest&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/opt/kde3/share/fonts&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/TTF/&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(WW) The directory &#8220;/usr/share/fonts/OTF&#8221; does not exist.</dt>
<dd>Entry deleted from font path.</dd>
<dt>(**) FontPath set to:</dt>
<dd>/usr/share/fonts/misc:unscaled,
/usr/share/fonts/75dpi:unscaled,
/usr/share/fonts/100dpi:unscaled,
/usr/share/fonts/Type1,
/usr/share/fonts/URW,
/usr/share/fonts/Speedo,
/usr/share/fonts/cyrillic,
/usr/share/fonts/truetype,
/usr/share/fonts/misc:unscaled,
/usr/share/fonts/truetype/,
/usr/share/fonts/Type1/,
/usr/share/fonts/100dpi:unscaled,
/usr/share/fonts/75dpi:unscaled</dd>
</dl>
<p>(**) Input device list set to &#8220;/dev/gpmdata,/dev/input/mice&#8221;
(==) ModulePath set to &#8220;/usr/lib64/xorg/modules/updates,/usr/lib64/xorg/modules&#8221;
(II) Loader magic: 0xcc0
(II) Module ABI versions:</p>
<blockquote>
<div>X.Org ANSI C Emulation: 0.4
X.Org Video Driver: 5.0
X.Org XInput driver : 4.0
X.Org Server Extension : 2.0</div></blockquote>
<p>(II) Loader running on linux
(++) using VT number 7</p>
<p>(&#8211;) PCI:<a href="#id46"><span class="problematic" id="id47">*</span></a>(0:1:0:0) 10de:17f0:10de:1129 nVidia Corporation rev 161, Mem &#64; 0xf6000000/16777216, 0xd0000000/268435456, 0xe0000000/33554432, I/O &#64; 0x0000e000/128, BIOS &#64; 0x????????/524288
(&#8211;) PCI: (0:4:0:0) 10de:1094:10de:0888 nVidia Corporation rev 161, Mem &#64; 0xf4000000/16777216, 0xe8000000/134217728, 0xf0000000/33554432, I/O &#64; 0x0000c000/128, BIOS &#64; 0x????????/524288
(II) Open ACPI successful (/var/run/acpid.socket)
(II) System resource ranges:</p>
<blockquote>
<div>[0] -1  0       0xffffffff - 0xffffffff (0x1) MX[B]
[1] -1  0       0x000f0000 - 0x000fffff (0x10000) MX[B]
[2] -1  0       0x000c0000 - 0x000effff (0x30000) MX[B]
[3] -1  0       0x00000000 - 0x0009ffff (0xa0000) MX[B]
[4] -1  0       0x0000ffff - 0x0000ffff (0x1) IX[B]
[5] -1  0       0x00000000 - 0x00000000 (0x1) IX[B]</div></blockquote>
<p>(II) &#8220;extmod&#8221; will be loaded. This was enabled by default and also specified in the config file.
(II) &#8220;dbe&#8221; will be loaded. This was enabled by default and also specified in the config file.
(II) &#8220;glx&#8221; will be loaded. This was enabled by default and also specified in the config file.
(II) &#8220;record&#8221; will be loaded by default.
(II) &#8220;dri&#8221; will be loaded by default.
(II) &#8220;dri2&#8221; will be loaded by default.
(II) LoadModule: &#8220;dbe&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/libdbe.so
(II) Module dbe: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.0.0
Module class: X.Org Server Extension
ABI class: X.Org Server Extension, version 2.0</div></blockquote>
<p>(II) Loading extension DOUBLE-BUFFER
(II) LoadModule: &#8220;freetype&#8221;
(WW) Warning, couldn&#8217;t open module freetype
(II) UnloadModule: &#8220;freetype&#8221;
(EE) Failed to load module &#8220;freetype&#8221; (module does not exist, 0)
(II) LoadModule: &#8220;extmod&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/libextmod.so
(II) Module extmod: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.0.0
Module class: X.Org Server Extension
ABI class: X.Org Server Extension, version 2.0</div></blockquote>
<p>(II) Loading extension MIT-SCREEN-SAVER
(II) Loading extension XFree86-VidModeExtension
(II) Loading extension XFree86-DGA
(II) Loading extension DPMS
(II) Loading extension XVideo
(II) Loading extension XVideo-MotionCompensation
(II) Loading extension X-Resource
(II) LoadModule: &#8220;glx&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/libglx.so
(II) Module glx: vendor=&#8221;NVIDIA Corporation&#8221;</p>
<blockquote>
<div>compiled for 4.0.2, module version = 1.0.0
Module class: X.Org Server Extension</div></blockquote>
<p>(II) NVIDIA GLX Module  dev_gpu_drv_cuda_a-20150129_19276027  Release Build  (cuda_a)  (19276027)  (<a class="reference external" href="mailto:buildmeister&#37;&#52;&#48;swio-display-x86-rhel47-07">buildmeister<span>&#64;</span>swio-display-x86-rhel47-07</a>)  Thu Jan 29 13:48:57 PST 2015
(II) Loading extension GLX
(II) LoadModule: &#8220;record&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/librecord.so
(II) Module record: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.13.0
Module class: X.Org Server Extension
ABI class: X.Org Server Extension, version 2.0</div></blockquote>
<p>(II) Loading extension RECORD
(II) LoadModule: &#8220;dri&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/libdri.so
(II) Module dri: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.0.0
ABI class: X.Org Server Extension, version 2.0</div></blockquote>
<p>(II) Loading extension XFree86-DRI
(II) LoadModule: &#8220;dri2&#8221;
(II) Loading /usr/lib64/xorg/modules//extensions/libdri2.so
(II) Module dri2: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.1.0
ABI class: X.Org Server Extension, version 2.0</div></blockquote>
<p>(II) Loading extension DRI2
(II) LoadModule: &#8220;nvidia&#8221;
(II) Loading /usr/lib64/xorg/modules//drivers/nvidia_drv.so
(II) Module nvidia: vendor=&#8221;NVIDIA Corporation&#8221;</p>
<blockquote>
<div>compiled for 4.0.2, module version = 1.0.0
Module class: X.Org Video Driver</div></blockquote>
<p>(II) LoadModule: &#8220;kbd&#8221;
(II) Loading /usr/lib64/xorg/modules//input/kbd_drv.so
(II) Module kbd: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.3.2
Module class: X.Org XInput Driver
ABI class: X.Org XInput driver, version 4.0</div></blockquote>
<p>(II) LoadModule: &#8220;mouse&#8221;
(II) Loading /usr/lib64/xorg/modules//input/mouse_drv.so
(II) Module mouse: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.4.0
Module class: X.Org XInput Driver
ABI class: X.Org XInput driver, version 4.0</div></blockquote>
<p>(II) NVIDIA dlloader X Driver  dev_gpu_drv_cuda_a-20150129_19276027  Release Build  (cuda_a)  (19276027)  (<a class="reference external" href="mailto:buildmeister&#37;&#52;&#48;swio-display-x86-rhel47-07">buildmeister<span>&#64;</span>swio-display-x86-rhel47-07</a>)  Thu Jan 29 13:25:31 PST 2015
(II) NVIDIA Unified Driver for all Supported NVIDIA GPUs
(II) Primary Device is: PCI <a class="reference external" href="mailto:01&#37;&#52;&#48;00">01<span>&#64;</span>00</a>:00:0
(II) Loading sub module &#8220;fb&#8221;
(II) LoadModule: &#8220;fb&#8221;
(II) Loading /usr/lib64/xorg/modules//libfb.so
(II) Module fb: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.0.0
ABI class: X.Org ANSI C Emulation, version 0.4</div></blockquote>
<p>(II) Loading sub module &#8220;wfb&#8221;
(II) LoadModule: &#8220;wfb&#8221;
(II) Loading /usr/lib64/xorg/modules//libwfb.so
(II) Module wfb: vendor=&#8221;X.Org Foundation&#8221;</p>
<blockquote>
<div>compiled for 1.6.5, module version = 1.0.0
ABI class: X.Org ANSI C Emulation, version 0.4</div></blockquote>
<p>(II) Loading sub module &#8220;ramdac&#8221;
(II) LoadModule: &#8220;ramdac&#8221;
(II) Module &#8220;ramdac&#8221; already built-in
(II) resource ranges after probing:</p>
<blockquote>
<div>[0] -1  0       0xffffffff - 0xffffffff (0x1) MX[B]
[1] -1  0       0x000f0000 - 0x000fffff (0x10000) MX[B]
[2] -1  0       0x000c0000 - 0x000effff (0x30000) MX[B]
[3] -1  0       0x00000000 - 0x0009ffff (0xa0000) MX[B]
[4] -1  0       0x0000ffff - 0x0000ffff (0x1) IX[B]
[5] -1  0       0x00000000 - 0x00000000 (0x1) IX[B]</div></blockquote>
<p>(**) NVIDIA(0): Depth 24, (&#8211;) framebuffer bpp 32
(==) NVIDIA(0): RGB weight 888
(==) NVIDIA(0): Default visual is TrueColor
(==) NVIDIA(0): Using gamma correction (1.0, 1.0, 1.0)
(**) Feb 04 06:42:13 NVIDIA(0): Enabling 2D acceleration
(II) Feb 04 06:42:14 NVIDIA(0): NVIDIA GPU Quadro M6000 (GM200GL-A) at PCI:1:0:0 (GPU-0)
(&#8211;) Feb 04 06:42:14 NVIDIA(0): Memory: 12582912 kBytes
(&#8211;) Feb 04 06:42:14 NVIDIA(0): VideoBIOS: 84.00.1b.00.01
(II) Feb 04 06:42:14 NVIDIA(0): Detected PCI Express Link width: 16X
(&#8211;) Feb 04 06:42:14 NVIDIA(0): Valid display device(s) on Quadro M6000 at PCI:1:0:0
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     CRT-0
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-0 (boot)
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-1
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-2
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-3
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-4
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-5
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-6
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-7
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-8
(&#8211;) Feb 04 06:42:14 NVIDIA(0):     DFP-9
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): CRT-0: 400.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-0: Internal TMDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-0: 330.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-1: Internal DisplayPort
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-1: 960.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-2: Internal TMDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-2: 330.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-3: Internal DisplayPort
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-3: 960.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-4: Internal TMDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-4: 330.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-5: Internal DisplayPort
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-5: 960.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-6: Internal TMDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-6: 330.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-7: Internal DisplayPort
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-7: 960.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-8: Internal TMDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-8: 330.0 MHz maximum pixel clock
(&#8211;) Feb 04 06:42:14 NVIDIA(0): DFP-9: External LVDS
(&#8211;) Feb 04 06:42:14 NVIDIA(GPU-0): DFP-9: 165.0 MHz maximum pixel clock
(EE) Feb 04 06:42:14 NVIDIA(0): Failed to assign any connected display devices to X screen 0.
(EE) Feb 04 06:42:14 NVIDIA(0):     Set AllowEmptyInitialConfiguration if you want the server
(EE) Feb 04 06:42:14 NVIDIA(0):     to start anyway
(EE) Feb 04 06:42:14 NVIDIA(0): Failing initialization of X screen 0
(II) UnloadModule: &#8220;nvidia&#8221;
(II) UnloadModule: &#8220;wfb&#8221;
(II) UnloadModule: &#8220;fb&#8221;
(EE) Screen(s) found, but none have a usable configuration.</p>
<p>Fatal server error:
no screens found</p>
<dl class="docutils">
<dt>Please consult the The X.Org Foundation support</dt>
<dd><blockquote class="first">
<div>at <a class="reference external" href="http://wiki.x.org">http://wiki.x.org</a></div></blockquote>
<p class="last">for help.</p>
</dd>
</dl>
<p>Please also check the log file at &#8220;/var/log/Xorg.0.log&#8221; for additional information.</p>
</div>
</div>
<div class="section" id="id48">
<h3>tty console<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h3>
<p>现在终于明白了tty的设计原理了。简单的理解，就是一个socket通信。并且把两端通用化。例如一些编辑的功能，例如具备一些editor的初步功能。
一个最简单功能，那就是直接for循环，就可以搞定。拿浏览器来做对比，就会一目了然，那就是终端也需要一定的rendering功能。 而这些不是应用程序本身需要
考虑的功能。</p>
<p>未来的terminal 趋向于全终端editor+ browser + session management 的功能。例如QTconsole能够支持图表与公式的功能。</p>
<p>例如tmux 来实现多session的管理。以及asciinema 的录制。
以及各个session之间的共享，其实就是socket的组播功能。</p>
<p>pts的原理，<a class="reference external" href="http://www.baike.com/ipadwiki/PTS">http://www.baike.com/ipadwiki/PTS</a></p>
<p>ssh,telnet这些与在本地的xterm都同相同地方，那就是其输入输出连接一个终端。并且都是双工通信或者三工通信，in,out,error.  而对于终端来说，那就是一个master,slave,一个读一个写。要正好与进程之间反过来才行。 而这些都是要终端打交道。</p>
<p>/dev/console 总是指向系统的TTY，它决定了系统的信息往哪里输出，/dev/tty0总是指向当前的tty, tty[1-x] 则是独立逻辑tty设备。</p>
</div>
<div class="section" id="id49">
<h3>terminal 中显示符号<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h3>
<p>这个关键是编码与字体的支持，只要有两者的支持就能显示，例如 <a class="reference external" href="https://unix.stackexchange.com/questions/96591/is-it-possible-to-show-mathematical-symbols-in-the-terminal">在terminal中显示数学符号</a></p>
</div>
<div class="section" id="id51">
<h3>远程网络shell之间<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<p>ssh 的过程。
远程网络终端和本机shell之间建立了一条双向通道&#8211;“远程网络终端-(套接字)&#8211;本机协议处理进程&#8211;主终端&#8211;从终端&#8211;shell”</p>
</div>
<div class="section" id="id52">
<h3>serial IO 的原理<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<p>CPU -&gt; driver -&gt;bus -&gt;I/O pin
<a class="reference external" href="http://www.tldp.org/HOWTO/Serial-HOWTO-4.html">http://www.tldp.org/HOWTO/Serial-HOWTO-4.html</a></p>
<p>import os
import glob</p>
<p>wiki_list = glob.glob(&#8220;<a href="#id53"><span class="problematic" id="id54">*</span></a>.txt&#8221;)
map(lambda x: os.system(&#8220;&#8221;&#8220;vim -c &#8221;:so twikifilter.vim&#8221; {}&#8221;&#8220;&#8221;.format(x)),wiki_list)</p>
<p>&#8221; process the link
&#8221;
echohl MatchParen | echo &#8220;process the link&#8221; | echohl None
%s/[[(.{-})][(.{-})]]/<a href="#id111"><span class="problematic" id="id112">`\2 &lt;\1&gt;`_</span></a> /g
&#8221; process %IF{ ....}% MACRO afer the list
%s/%IF{.{-}}%//g</p>
<p>echohl MatchParen | echo &#8220;process Headline&#8221; | echohl None
%s/+++zs[^ ]/ &amp;/
&#8221; process the Headline &#8212;+++
g/&#8212;+++ /s/&#8212;+++ // <a href="#id55"><span class="problematic" id="id56">|</span></a>t. <a href="#id57"><span class="problematic" id="id58">|</span></a>s/.*/=repeat(&#8220;=&#8221;,len(submatch(0))). &#8220;r&#8221;/
&#8221; process the Headline &#8212;++++
g/&#8212;++++ /s/&#8212;++++ // <a href="#id59"><span class="problematic" id="id60">|</span></a>t. <a href="#id61"><span class="problematic" id="id62">|</span></a>s/.*/=repeat(&#8220;=&#8221;,len(submatch(0))). &#8220;r&#8221;/</p>
<p>echohl MatchParen | echo &#8220;process graphviz&#8221; | echohl None
&#8221; process graphviz
&#8221;
g/&lt;dot&gt;/,/&lt;/dot&gt;/s/.*/   &amp;/
g/&lt;dot&gt;/,/&lt;/dot&gt;/s/.*&lt;dot&gt;/r.. graphviz::r
%s/&lt;/dot&gt;/r/g</p>
<p>echohl MatchParen | echo &#8220;process verbatim&#8221; | echohl None
&#8221; process verbatim
g/&lt;verbatim&gt;/,/&lt;/verbatim&gt;/s/.*/   &amp;/
%s/&lt;verbatim&gt;(_.{-})&lt;/verbatim&gt;/r.. ::r 1r/</p>
<p>echohl MatchParen | echo &#8220;process blockqote&#8221; | echohl None
&#8221; process blockquote
&#8221;
g/&lt;blockquote.*&gt;/,/&lt;/blockquote&gt;/s/.*/   &amp;/
%s/&lt;blockquote.*&gt;(_.{-})&lt;/blockquote&gt;/r.. ::r 1r/</p>
<p>&#8221; Process the <a href="#id63"><span class="problematic" id="id64">*</span></a>list
&#8221;
echohl MatchParen | echo &#8220;process the <a href="#id65"><span class="problematic" id="id66">*</span></a>list&#8221; | echohl None
%s/   * /#. /
%s/   1. /#. /</p>
<p>&#8221; Process the table
&#8221;
echohl MatchParen <a href="#id67"><span class="problematic" id="id68">|</span></a>echo &#8220;process the table&#8221; <a href="#id69"><span class="problematic" id="id70">|</span></a>echohl None</p>
<p>%s/^[^|]*_szs(_^ <a href="#id71"><span class="problematic" id="id72">*</span></a><a href="#id105"><span class="problematic" id="id106">|\_.\{-}\)\ze\_^[^|</span></a>]*$/r.. csv-table:: rr&amp;r/g
%g/^ <a href="#id73"><span class="problematic" id="id74">*</span></a><a href="#id107"><span class="problematic" id="id108">|/s/|</span></a>/,/g
%g/^ <a href="#id75"><span class="problematic" id="id76">*</span></a>,/s/^ <a href="#id77"><span class="problematic" id="id78">*</span></a>, {0,2}/   /g</p>
<p>&#8221; Process the math
&#8221;
echohl MatchParen <a href="#id79"><span class="problematic" id="id80">|</span></a>echo &#8220;process the math&#8221; <a href="#id81"><span class="problematic" id="id82">|</span></a>echohl None
%s/%$(.*)$%/r.. math:: 1/g</p>
<p>&#8221; Process the %META
&#8221;
echohl MatchParen <a href="#id83"><span class="problematic" id="id84">|</span></a>echo &#8220;process the Meta&#8221; <a href="#id85"><span class="problematic" id="id86">|</span></a>echohl None
:g/%META/d</p>
<p>&#8221; Process the %Reference
&#8221;
echohl MatchParen <a href="#id87"><span class="problematic" id="id88">|</span></a>echo &#8220;process the Referencelink&#8221; <a href="#id89"><span class="problematic" id="id90">|</span></a>echohl None
:g/#Re/,/ENDTWISTY/d
:g/TWISTY/d
echohl MatchParen | echo &#8221;:)(:  Finish&#8221; | echohl None</p>
<p>&#8220;wq!</p>
</div>
</div>
<div class="section" id="id91">
<h2>虚拟化<a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h2>
<p>虚拟化本质就是松耦合，接口化。 加一个中间层。最简单的虚拟化就是 输入输出的重定向。 因为正常的情况下程序没有打开多余的输入输出的。只有0，1，2.程序只认0，1，2.不管他们绑在谁身上。</p>
<p>再复杂一些虚拟化chroot,这样上升到context的切换。 但还不够。程序最初的设计是代码与数据分离的。 但是代码与执行本身强耦合的。这也是为什么大部分情况下，一般人讲进程与代码的关系的讲不清的原因。</p>
<p>更进一步的虚拟就是代码，数据，执行三者都是分离的。因为当初的设计，代码的执行context要求比较大那就是 OS级的context. 也就是你看到虚拟机。有两种一种是 JVM这种。另一种那就是 virtual box以及更一层的Xen 这种。</p>
<p>从实现上只是执行与代码的分离，而在linux 中还出现多细分的。
<a class="reference external" href="http://www.ibm.com/developerworks/cn/linux/l-lxc-containers/index.html">LXC: Linux 容器工具</a>  这个实现正是基于chroot 实现的进程级别的虚拟化。
<a class="reference external" href="http://blog.csdn.net/cbmsft/article/details/7214371">http://blog.csdn.net/cbmsft/article/details/7214371</a></p>
<p>Docker 是一种更轻质化的容器,就为了实现大一统,达到资源与效率的平衡.
Docker 可以做什么 <a class="reference external" href="http://blog.2baxb.me/archives/1136">http://blog.2baxb.me/archives/1136</a></p>
<div class="section" id="docker">
<h3>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h3>
<p>最快的安装方式，<strong class="command">curl -sSL https://get.docker.com/ |sh -</strong>
并且Docker现在发展的很成熟，可以实现各种level的虚拟化。</p>
<p>一个进程的，直接使用 <strong class="command">docker run</strong> 或者多进程service级别的docker-composer.
以及多host的docker-machine(自动安装docker）,以及集群水平的swarms,`Kubernetes &lt;<a class="reference external" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a>&gt;`_ (google开发的自动部署的docker工具)，能够实现load labance. 同时能够提供虚拟的网络的，overlay.</p>
<p>同时也提供自动配置，Dockerfile ,Compose.yaml 等等。</p>
<p>对于数据存储资源可以 volume绑定.</p>
<p>对于docker image的存储可以有自建registery. 同时还有各家的docker cloud可以用。</p>
<ol class="arabic simple">
<li>常用命令的查询 <a class="reference external" href="https://github.com/eon01/DockerCheatSheet">Docker</a></li>
<li>中文版不错的书 <a class="reference external" href="https://www.gitbook.com/book/yeasy/docker_practice/details">Docker 从入门到实践</a></li>
<li>Docker 的存储实现原理 <a class="reference external" href="https://segmentfault.com/a/1190000007168476">https://segmentfault.com/a/1190000007168476</a>，不同文件系统支持的水平与性能也都不一样。</li>
</ol>
<p>dokcer 对于集群的支持 有Docker service,以及swarm等模式的支持。 <a class="reference external" href="http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/">http://liubin.org/blog/2016/06/17/whats-new-in-docker-1-dot-12-dot-0/</a></p>
</div>
<div class="section" id="how-to-upload-to-hub-docker-com">
<h3>how to upload to hub.docker.com<a class="headerlink" href="#how-to-upload-to-hub-docker-com" title="Permalink to this headline">¶</a></h3>
<div class="highlight-bash"><div class="highlight"><pre>docker images
docker tag  bb38976d03cf yourhubusername/verse_gapminder:firsttry
docker push yourhubusername/verse_gapminder:firsttry
</pre></div>
</div>
</div>
<div class="section" id="how-to-automate-build-from-with-github">
<h3>how to automate-build from with Github<a class="headerlink" href="#how-to-automate-build-from-with-github" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="guihost">
<h3>共享GUI与host<a class="headerlink" href="#guihost" title="Permalink to this headline">¶</a></h3>
<p>主要是采用的方式，那就是共享socket 的模式。</p>
</div>
<div class="section" id="permission">
<h3>permission<a class="headerlink" href="#permission" title="Permalink to this headline">¶</a></h3>
<div class="highlight-bash"><div class="highlight"><pre>docker: Got permission denied <span class="k">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/containers/create: dial unix /var/run/docker.sock: connect: permission denied.
See <span class="s1">&#39;docker run --help&#39;</span>.
sudo usermod -a -G docker $USER
logout/login
</pre></div>
</div>
<div class="section" id="network-and-service">
<h4>network and service<a class="headerlink" href="#network-and-service" title="Permalink to this headline">¶</a></h4>
<p>docker &#8211;run &#8211;it &#8211;net=bridge
在Docker的container里起一个sshi serivice</p>
<div class="highlight-bash"><div class="highlight"><pre>apt update <span class="o">&amp;&amp;</span> apt install openssh-server
/usr/sbin/sshd
<span class="c1">#. config the sshd alow the root</span>
docker run -p  8022:22
</pre></div>
</div>
</div>
</div>
<div class="section" id="grid">
<h3>Grid<a class="headerlink" href="#grid" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>vGPU profile 决定你的vGPU type.
每一块物理卡可以虚拟出多块vGPU,但是必须是同一类型
分配策略，深度优先，把一个块物理卡用完再用第二块卡，第二种广度优先，尽可能用新卡。</li>
<li><a class="reference external" href="http://www.nvidia.com/object/nvidia-grid-buy.html">http://www.nvidia.com/object/nvidia-grid-buy.html</a></li>
<li><a class="reference external" href="https://www.youtube.com/watch?v=_CQmomyOiRM">NVIDIA GRID vGPU explained</a></li>
<li>Windows server 2016 版本对比 <a class="reference external" href="https://docs.microsoft.com/zh-cn/windows-server/get-started/2016-edition-comparison">https://docs.microsoft.com/zh-cn/windows-server/get-started/2016-edition-comparison</a></li>
<li>type 2 与type 1 的区别 <a class="reference external" href="https://blogs.technet.microsoft.com/jhoward/2013/10/24/hyper-v-generation-2-virtual-machines-part-1/">https://blogs.technet.microsoft.com/jhoward/2013/10/24/hyper-v-generation-2-virtual-machines-part-1/</a></li>
</ol>
<p>#. NVIDIA GRID 对Hyper-V 的支持
<a class="reference external" href="https://virtuallyvisual.wordpress.com/2017/01/18/nvidia-grid-and-microsoft-windows-server-oss-and-hyper-v/">https://virtuallyvisual.wordpress.com/2017/01/18/nvidia-grid-and-microsoft-windows-server-oss-and-hyper-v/</a></p>
<ol class="arabic simple">
<li>Latest GRID 5.0 <a class="reference external" href="https://thevirtualhorizon.com/2017/08/17/grid-5-0-pascal-support-and-more/">https://thevirtualhorizon.com/2017/08/17/grid-5-0-pascal-support-and-more/</a></li>
</ol>
<p>steps</p>
</div>
<div class="section" id="wayland">
<h3>wayland<a class="headerlink" href="#wayland" title="Permalink to this headline">¶</a></h3>
<p>相当于是简化了,XWindowServer的流程，尽可能让App直接与kernel通信，自己来管理显示。
<a class="reference external" href="https://wayland.freedesktop.org/architecture.html">https://wayland.freedesktop.org/architecture.html</a>
<a class="reference external" href="https://zh.wikipedia.org/wiki/Wayland">https://zh.wikipedia.org/wiki/Wayland</a></p>
<p>主要是为解决效率问题。</p>
</div>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>在linux中接处最多就是终端，所以熟悉各种的使用技巧与用法，可以大大的提高效率。同时也可以打开多终端实现多用户的并行操作。或者使用expect来实现多用户交互。或者直接使用socket 来进行模似。</p>
</div>
<div class="section" id="windows-manager">
<h3>windows manager<a class="headerlink" href="#windows-manager" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference external" href="http://www.fvwm.org/">fvwm</a>  <a class="reference external" href="http://home.ustc.edu.cn/~lixuebai/GNU/FVWM.html">a good introduction</a></td>
<td>amiwm</td>
<td>icewm</td>
<td>windowmaker</td>
<td>afterstep</td>
<td>sawfish</td>
<td>kwm</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p><em>FVWM</em> 它的采用与Xwindows 通过语法格式。设置一些全局变量，对于是ImagePath,Button,Menu等控制。以及键盘消息的映射。窗口布局的管理。对它的使用也像VIM的配置文件一样。先找来一个模板，然后根据自己的需求来改。 FVWM另外强大的一点那就是可以SHELL 进行交互。也就是配置文件是可以动态的生成的。这样就极大提搞了其灵活性。</p>
</div>
<div class="section" id="toolkit">
<h3>Toolkit<a class="headerlink" href="#toolkit" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>motif</td>
<td>XForms</td>
<td>FLTK</td>
<td>Gtk</td>
<td>Qt</td>
<td>LessTif</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="desktop-environments">
<h3>Desktop Environments<a class="headerlink" href="#desktop-environments" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CDE Common Desktop Environment</td>
<td>KDE</td>
<td>GNOME</td>
<td>GUNStep</td>
<td>ROX</td>
<td>GTK+XFce</td>
<td>UDE</td>
<td><a class="reference external" href="http://step.polymtl.ca/~coyote/xview_main.html">Xview/OpenLook</a></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="file-manager">
<h3>FIle manager<a class="headerlink" href="#file-manager" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>gmc</td>
<td>Nautilus</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>#StandIOTerminal
terminal
========</p>
<p>首先要搞明白的这个定义，终端就是可以主机进行输入输出通信的设备。对于终端的分类与介绍在OS Design and Implementation有详细的介绍。基本上分三类：%BR%&lt;img src=&#8221;%ATTACHURLPATH%/TerminalType.jpg&#8221; alt=&#8221;TerminalType.jpg&#8221;  /&gt;</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference external" href="http://invisible-island.net/xterm/xterm.faq.html">xterm</a></td>
<td>&nbsp;</td>
<td>功能强大，最初版本</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dtterm</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>rvxt</td>
<td>支持更好的画面，同时支持perl脚本扩展</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>xterm tty pts pty 的区别</td>
<td><a class="reference external" href="http://kpshare.blog.51cto.com/1195439/275837">概念区分一</a>  <a class="reference external" href="http://topic.csdn.net/u/20100201/17/a34370cc-8a61-4315-a4d0-84242362064d.html">概念区分之一</a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>所以对于终端的控制主要是两大类，一个是对其输入的控制，一个就是对其输出控制。 在linux中使用`termInfo &lt;<a class="reference external" href="http://billtym.blog.51cto.com/1745172/418510">http://billtym.blog.51cto.com/1745172/418510</a>&gt;`_ 来配置终端。其实所有的操作最终都是通过它来起作用。其实是UNIX哲学中，所有算法都是围绕数据结构转的。
#. <em>对输入的控制</em> 对于输入模式主要有常见两种那就是RAW模式与cooked 模式。另外一个那就是echo 与否。例外就是一些特殊字符的输入，以及编辑习惯都是都可以设置的，一个重要的话题，对其进行配置，这个可以通过profile 与.shellrc这些文件来进行配置。%BR%</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>setty</td>
<td>来进行对于输入进行各种设置</td>
<td>setty -echo</td>
<td>set -o</td>
<td>settty</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><em>对于输出的控制</em> %BR%</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>颜色与光标的移动</td>
<td><a class="reference external" href="http://www.ibm.com/developerworks/cn/aix/library/au-learningtput/index.html">tput入门使用 IBM</a>   <a class="reference external" href="http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html">tput user manual</a></td>
<td>想要对屏幕显示进行个性化设置，可以利用这个命令，例如在屏幕上实现语法高亮等等。</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>^</td>
<td>通过转义字符来实现 ESC [</td>
<td>使用echo -e  &#8220;ESC [ XX &#8221; 来使用</td>
<td><a class="reference external" href="http://blog.sina.com.cn/s/blog_613454190100lzwl.html">使用ncurses来操作或者开发</a></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><em>对于TTY的管理控制</em>  TTY也也是C/S模式，分主端，与从端。一般情况下，主端都是系统建好的。%BR%</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference external" href="http://docs.sun.com/app/docs/doc/819-6951/modsafapp-18?l=zh&amp;a=view">如何查看TTY端口的服务状态</a></td>
<td>pmadm</td>
<td>ttyadm</td>
<td>contty</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>如何连接，与配置</td>
<td><a class="reference external" href="http://www.deansys.com/doc/ldd3/ch18.html">linux 设备驱动，TTY驱动</a></td>
<td><a class="reference external" href="http://stevens0102.blogbus.com/logs/47327581.html">getty</a>  连接tty  <a href="#id96"><span class="problematic" id="id97">`</span></a>清除被占用的tty端口的方法</td>
<td>rmdev</td>
<td>stty-cxms fuser</td>
<td>pdisalble</td>
<td>strreset &lt;<a class="reference external" href="http://blog.chinaunix.net/u/25969/showart_1084733.html">http://blog.chinaunix.net/u/25969/showart_1084733.html</a>&gt;`_</td>
<td>` mkdev  &lt;<a class="reference external" href="http://study.chyangwa.com/IT/AIX/aixcmds3/mkdev.htm">http://study.chyangwa.com/IT/AIX/aixcmds3/mkdev.htm</a>&gt;`_</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id98">
<h3>终端使用技巧<a class="headerlink" href="#id98" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>共享terminal环境。利用screen 命令。</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference external" href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/">使用 screen 管理你的远程会话</a></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><a class="reference external" href="http://hooney.javaeye.com/blog/167062">term 转义字符大全以及颜色大全</a></li>
<li><a class="reference external" href="http://study.chyangwa.com/IT/AIX/aixcmds6/xterm.htm">xterm 命令大全</a></li>
<li><a class="reference external" href="http://www.perlmonks.org/?node_id=569933">rxvt perl 二次开发</a></li>
<li>` tty,pty 区别与模式 &lt;<a class="reference external" href="http://www.svn8.com/linux/WL/20091223/15601.html">http://www.svn8.com/linux/WL/20091223/15601.html</a>&gt;`_</li>
<li><a class="reference external" href="http://blogold.chinaunix.net/u3/103643/showart_2200383.html">为什么要用PTY</a></li>
<li><a class="reference external" href="http://topic.csdn.net/t/20060426/13/4715138.html">PTY 开发</a></li>
<li><a class="reference external" href="http://study.chyangwa.com/IT/AIX/aixcmds6/mastertoc.htm#mtoc">linux 命令大全</a></li>
</ol>
</div>
<div class="section" id="id102">
<h3>Introduction<a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Xvfb">http://en.wikipedia.org/wiki/Xvfb</a> virtual is reality. it come to true. due the hardware, we could have logic device for it.</p>
</div>
<div class="section" id="see-also">
<h3>See also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><a class="reference external" href="http://ued.taobao.com/blog/2010/07/xvfb&amp;#95;yslow&amp;#95;showslow-2/">Xvfb+YSlow+ShowSlow搭建前端性能测试框架</a></li>
<li><a class="reference external" href="http://blog.saymoon.com/2009/11/take-snapshot-in-linux-command-line/">linux命令行抓取网页快照-（xvfb+CutyCapt）</a></li>
<li><a class="reference external" href="http://www.gentoo.org/doc/zh&amp;#95;cn/fluxbox-config.xml">Fluxbox配置指南</a></li>
<li><a class="reference external" href="http://linuxtoy.org/archives/openbox-getting-started-guide.html">openbox</a></li>
<li><a class="reference external" href="http://wiki.ubuntu.org.cn/&amp;#37;E4&amp;#37;BD&amp;#37;8E&amp;#37;E9&amp;#37;85&amp;#37;8D&amp;#37;E7&amp;#37;BD&amp;#37;AE&amp;#37;E7&amp;#37;94&amp;#37;B5&amp;#37;E8&amp;#37;84&amp;#37;91&amp;#37;E5&amp;#37;AE&amp;#37;89&amp;#37;E8&amp;#37;A3&amp;#37;85">低配置电脑安装</a>  各个部分的需求</li>
</ol>
</div>
<div class="section" id="id104">
<h3>Thinking<a class="headerlink" href="#id104" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">专题篇</a><ul>
<li><a class="reference internal" href="#linux-bootup">linux bootup</a><ul>
<li><a class="reference internal" href="#linux">linux 的生与死</a><ul>
<li><a class="reference internal" href="#id2">如何把添加卡到默认启动</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">内核的启动与一般函数调用</a><ul>
<li><a class="reference internal" href="#initrd">解压 initrd</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">无盘启动</a></li>
<li><a class="reference internal" href="#how-to-config-pxe-server">how to config PXE server</a></li>
<li><a class="reference internal" href="#boot-from-nfs">boot from nfs</a></li>
<li><a class="reference internal" href="#boot-from-http">boot from http</a></li>
<li><a class="reference internal" href="#id8">动态的启动脚本</a></li>
<li><a class="reference internal" href="#booting-from-pxe-of-realtek-of-agent">Booting from PXE of Realtek of agent</a></li>
<li><a class="reference internal" href="#id9">无盘启动方案</a></li>
<li><a class="reference internal" href="#tty-console">tty console</a></li>
<li><a class="reference internal" href="#terminal">terminal 中显示符号</a></li>
<li><a class="reference internal" href="#shell">远程网络shell之间</a></li>
<li><a class="reference internal" href="#serial-io">serial IO 的原理</a></li>
<li><a class="reference internal" href="#io">IO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usboverip">USBOverIP</a><ul>
<li><a class="reference internal" href="#id11">基本流程</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">linux bootup</a><ul>
<li><a class="reference internal" href="#id13">linux 的生与死</a><ul>
<li><a class="reference internal" href="#id16">如何把添加卡到默认启动</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">内核的启动与一般函数调用</a><ul>
<li><a class="reference internal" href="#id19">解压 initrd</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26">无盘启动</a></li>
<li><a class="reference internal" href="#id27">how to config PXE server</a></li>
<li><a class="reference internal" href="#id28">boot from nfs</a></li>
<li><a class="reference internal" href="#id29">boot from http</a></li>
<li><a class="reference internal" href="#id30">动态的启动脚本</a></li>
<li><a class="reference internal" href="#id31">Booting from PXE of Realtek of agent</a></li>
<li><a class="reference internal" href="#id32">无盘启动方案</a></li>
<li><a class="reference internal" href="#input">Input设备</a><ul>
<li><a class="reference internal" href="#thinking">thinking</a></li>
<li><a class="reference internal" href="#id35">操作模型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id48">tty console</a></li>
<li><a class="reference internal" href="#id49">terminal 中显示符号</a></li>
<li><a class="reference internal" href="#id51">远程网络shell之间</a></li>
<li><a class="reference internal" href="#id52">serial IO 的原理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id91">虚拟化</a><ul>
<li><a class="reference internal" href="#docker">Docker</a></li>
<li><a class="reference internal" href="#how-to-upload-to-hub-docker-com">how to upload to hub.docker.com</a></li>
<li><a class="reference internal" href="#how-to-automate-build-from-with-github">how to automate-build from with Github</a></li>
<li><a class="reference internal" href="#guihost">共享GUI与host</a></li>
<li><a class="reference internal" href="#permission">permission</a><ul>
<li><a class="reference internal" href="#network-and-service">network and service</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grid">Grid</a></li>
<li><a class="reference internal" href="#wayland">wayland</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#windows-manager">windows manager</a></li>
<li><a class="reference internal" href="#toolkit">Toolkit</a></li>
<li><a class="reference internal" href="#desktop-environments">Desktop Environments</a></li>
<li><a class="reference internal" href="#file-manager">FIle manager</a></li>
<li><a class="reference internal" href="#id98">终端使用技巧</a></li>
<li><a class="reference internal" href="#id102">Introduction</a></li>
<li><a class="reference internal" href="#see-also">See also</a></li>
<li><a class="reference internal" href="#id104">Thinking</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Stage_2.html"
                        title="previous chapter">内核篇</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/content/Stage_3.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Stage_2.html" title="内核篇"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">My Linux 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, gangwei.li.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>